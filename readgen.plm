readgen:
    do;

$include (d:iocld.src)

    declare pointer literally 'address';
    declare word literally 'address';
    declare boolean literally 'byte';
    declare true literally '1';
    declare false literally '0';

    declare space literally '20h';
    declare tab literally '9h';
    declare lf literally '0ah';
    declare cr literally '0dh';

    declare tail$start literally '80h';

    print$string: procedure (p$str);
        declare p$str pointer;
        declare chr based p$str byte;
        do while chr <> 0;
            call wr$con(chr);
            p$str = p$str + 1;
        end;
    end print$string;

    print$char: procedure (chr);
        declare chr byte;
        call wr$con(chr);
    end print$char;

    new$line: procedure;
        call print$char(cr);
        call print$char(lf);
    end new$line;

    print$line: procedure (p$str);
        declare p$str pointer;
        call print$string(p$str);
        call new$line;
    end print$line;

    string$equal: procedure (p$str1, p$str2) boolean;
        declare (p$str1, p$str2) pointer;
        declare str1 based p$str1 byte;
        declare str2 based p$str2 byte;
        do while str1 <> 0 and str2 <> 0 and str1 = str2;
            p$str1 = p$str1 + 1;
            p$str2 = p$str2 + 1;
        end;
        return str1 = 0 and str2 = 0;
    end string$equal;


    /* READER */
    /* reader variables */
    declare reader$ptr pointer;   /* pointer to the current string */
    declare reader$chr based reader$ptr byte;

    input$end: procedure boolean;
        return reader$chr = 0;
    end input$end;

    next$char: procedure;
        reader$ptr = reader$ptr + 1;
    end next$char;


    /* TOKENIZER */
    /* tokenizer variables */
    declare token$ready boolean initial (false);
    declare token$id byte;
    declare token$value word;
    declare token$str pointer;
    declare tbuf$len literally '80h';
    declare tok$buf (tbuf$len) byte;

    /* token ids */
    declare end$of$input literally '0';
    declare keyword literally '1';
    declare identifier literally '2';
    declare number literally '3';

    /* check whether the character is an identifier or a keyword character */
    word$char: procedure (chr) boolean;
        declare chr byte;
        if chr >= 'a' and chr <= 'z' then
            return true;
        if chr >= 'A' and chr <= 'Z' then
            return true;
        if chr >= '0' and chr <= '9' then
            return true;
        if chr = '$' or chr = '_' then
            return true;
        return false;
    end word$char;

    /* check whether the character is a decimal digit */
    dec$char: procedure (chr) boolean;
        declare chr byte;
        return chr >= '0' and chr <= '9';
    end dec$char;

    /* checks whether chr is equivalent to a space */
    space$char: procedure (chr) boolean;
        declare chr byte;
        return chr = space or chr = tab or chr = lf or chr = cr;
    end space$char;

    /* skips characters equivalent to a space */
    /* TODO: also skip comments */
    skip$spaces: procedure pointer;
        do while space$char(reader$chr);
            call next$char;
        end;
    end skip$spaces;

    /* read a string that may be an identifier or a keyword */
    read$word: procedure;
        declare buffer$ptr pointer;
        declare buffer$chr based buffer$ptr byte;
        buffer$ptr = .tok$buf;
        token$id = identifier;
        token$str = buffer$ptr;
        /* TODO: check buffer length before writing! */
        /* buffer length is in constant tbuf$len */
        do while not input$end and word$char(reader$chr);
            buffer$chr = reader$chr;
            buffer$ptr = buffer$ptr + 1;
            call next$char;
        end;
        buffer$chr = 0;
        token$ready = true;
    end read$word;

    read$char: procedure;
        if not input$end then
            call next$char;
        token$id = 0ffh;
        /* TODO: determine token$id based on the character */
        token$ready = true;
    end read$char;

    read$number: procedure;
        /* TODO: implement */
        token$id = number;
        token$value = 0ffffh;
        call next$char;
        token$ready = true;
    end read$number;


    read$token: procedure;
        call skip$spaces;    /* skip spaces before reading the next token */
        if input$end then
            token$id = end$of$input;
        else if dec$char(reader$chr) then
            call read$number;
        else if word$char(reader$chr) then
            call read$word;
        else
            call read$char;
    end read$token;

    get$token: procedure byte;
        call print$line(.('get$token', 0));
        if not token$ready then
            call read$token;
        return token$id;
    end get$token;


    /* print token without new line */
    print$token: procedure;
        call print$string(.('TOKEN: ', 0));
        if token$id = identifier then
        do;
            call print$string(.('IDENTIFIER:', 0));
            call print$string(token$str);
        end;
        else if token$id = end$of$input then
            call print$string(.('END OF INPUT', 0));
        else
            call print$string(.('UNKNOWN TOKEN', 0));
    end print$token;

    /* MAIN PROGRAM */
    declare tail$ptr pointer;
    declare tail$chr based tail$ptr byte;
    declare tail$len byte;
    declare i byte;

    tail$ptr = tail$start;
    tail$len = tail$chr;
    tail$ptr = tail$ptr + tail$len + 1;
    tail$chr = 0;
    call print$string(.('string entered: {', 0));
    call print$string(tail$start + 1);
    call print$line(.('}', 0));
    reader$ptr = tail$start + 2;
    i = 0;
    do while i < 4 and not get$token = end$of$input;
        call print$string(reader$ptr);
        call print$line(.('$', 0));
        /* TODO: tokenizer interface (read$token, get$token)?? */
        call print$token;
        call new$line;
        call read$token;
        i = i + 1;
    end;

end;
