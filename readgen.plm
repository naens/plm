readgen:
    do;

$include (d:iocld.src)

    declare pointer literally 'address';
    declare word literally 'address';
    declare boolean literally 'byte';
    declare true literally '1';
    declare false literally '0';

    declare space literally '20h';
    declare tab literally '9h';
    declare lf literally '0ah';
    declare cr literally '0dh';

    declare tail$start literally '80h';

    print$string: procedure (p$str);
        declare p$str pointer;
        declare chr based p$str byte;
        do while chr <> 0;
            call wr$con(chr);
            p$str = p$str + 1;
        end;
    end print$string;

    print$char: procedure (chr);
        declare chr byte;
        call wr$con(chr);
    end print$char;

    new$line: procedure;
        call print$char(cr);
        call print$char(lf);
    end new$line;

    print$line: procedure (p$str);
        declare p$str pointer;
        call print$string(p$str);
        call new$line;
    end print$line;

    string$equal: procedure (p$str1, p$str2) boolean;
        declare (p$str1, p$str2) pointer;
        declare str1 based p$str1 byte;
        declare str2 based p$str2 byte;
        do while str1 <> 0 and str2 <> 0 and str1 = str2;
            p$str1 = p$str1 + 1;
            p$str2 = p$str2 + 1;
        end;
        return str1 = 0 and str2 = 0;
    end string$equal;


    /* READER */
    /* reader variables */
    declare reader$ptr pointer;   /* pointer to the current string */
    declare reader$chr byte;

    input$end: procedure boolean;
        return reader$chr = 0;
    end input$end;

    next$char: procedure;
        reader$ptr = reader$ptr + 1;
    end next$char;


    /* TOKENIZER */
    /* tokenizer variables */
    declare token$ready boolean;
    declare token$id byte;
    declare token$value word;
    declare token$str pointer;
    declare tbuf$len literally '80h';
    declare tok$buf (tbuf$len) byte;

    /* token ids */
    declare end$of$input literally '0';
    declare keyword literally '1';
    declare identifier literally '2';
    declare number literally '3';

    /* check whether the character is an identifier or a keyword character */
    word$char: procedure (chr) boolean;
        declare chr byte;
        if chr >= 'a' and chr <= 'z' then
            return true;
        if chr >= 'A' and chr <= 'Z' then
            return true;
        if chr >= '0' and chr <= '9' then
            return true;
        if chr = '$' or chr = '_' then
            return true;
        return false;
    end word$char;

    /* checks whether chr is equivalent to a space */
    space$char: procedure (chr) boolean;
        declare chr byte;
        return chr = space or chr = tab or chr = lf or chr = cr;
    end space$char;

    /* skips characters equivalent to a space */
    /* TODO: also skip comments */
    skip$spaces: procedure pointer;
        do while space$char(reader$chr);
            call next$char;
        end;
    end skip$spaces;

    /* read a string that may be an identifier or a keyword */
    read$word: procedure;
        declare buffer$ptr pointer;
        declare buffer$chr based buffer$ptr byte;
        buffer$ptr = .tok$buf;
        token$id = identifier;
        token$str = reader$ptr;
        /* TODO: check buffer length before writing! */
        /* buffer length is in constant tbuf$len */
        do while not input$end and word$char(reader$chr);
            buffer$chr = reader$chr;
            buffer$ptr = buffer$ptr + 1;
            call next$char;
        end;
    end read$word;

    read$char: procedure;
        if not input$end then
            call next$char;
        /* TODO: set token$id */
    end read$char;

    read$token: procedure;
        call skip$spaces;    /* skip spaces before reading the next token */
        if input$end then
            token$id = end$of$input;
        else if word$char(reader$chr) then
            call read$word;
        else
            call read$char;
    end read$token;

    get$token: procedure byte;
        if not token$ready then
            call read$token;
        return token$id;
    end get$token;


    /* MAIN PROGRAM */
    declare tail$ptr pointer;
    declare tail$chr based tail$ptr byte;
    declare tail$len byte;

    tail$ptr = tail$start;
    tail$len = tail$chr;
    tail$ptr = tail$ptr + tail$len + 1;
    tail$chr = 0;
    call print$string(.('string entered: {', 0));
    call print$string(tail$start + 1);
    call print$line(.('}', 0));

end;
