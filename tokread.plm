/****h* plm/tokread
 *
 * NAME
 *   tokread -- Tokenizer and Reader module
 *
 * DESCRIPTION
 *   The tokread module is responsible for reading from a source file and to
 *   convert source code to tokens.  Tokens are items that correspond to units
 *   of code in the source file.  The different kinds of tokens are identified
 *   by the token identifier and for some kinds of tokens it also has data,
 *   which is either a number of a string.  Many tokens do not have additional
 *   information.
 *
 *   The Tokenizer and the Reader work together, and therefore have a common
 *   interface.  The tokenizer, being of a higher level than the reader,
 *   has the majority of the interface functions (read a token, go to next,
 *   and so on).  The only way the user should interact with the reader is when
 *   setting the source.  Duting the normal execution, the reader reads from
 *   source files which are given to the reader in the form of the filename.
 *   For debug purposes, it's also possible to read from a string.
 *
 *   This is how the tokread module works:
 *   * the user initializes the reader by setting the filename of the source
 *     file,
 *   * then to read one token the user calls get$token, which returns the
 *     identifier of the token read.  On end of input it returns the tok$eof
 *     token, which is consistent with how parsers are usually described in
 *     literature.
 *   * For additional data from the token, the value is stored in tkn$val
 *     if it's a token with a numeric value. And when the token
 *     is of a type that contains a string (identifiers and string literals),
 *     the pointer to the string is stored in tkn$str external variable
 *     Both the number and the string values are temporary, so if the user
 *     intends to keep them for later use, he has to make a copy of them.
 *   * When the user has finished using the token and wants to move to the next
 *     one, he calls the tok$next function.  This function does not return
 *     anything as its only purpose is to advance to the next token.  To check
 *     the end of input condition and the token, get$token is used.
 *
 ******/

tokread:
do;

$include (d:iocld.src)

$include (globlit.inc)
$include (toklit.inc)
$include (string.plm)
$include (cons.plm)

    /* READER */
    /* reader variables */
    declare reader$ptr pointer;   /* pointer to the current string */
    declare reader$chr based reader$ptr byte;
    declare reader$prev byte initial (0);
    declare reader$saved byte initial (0);

    reader$set$ptr: procedure (ptr) public;
        declare ptr pointer;
        reader$ptr = ptr;
    end reader$set$ptr;

    input$end: procedure boolean;
        return reader$chr = 0;
    end input$end;

    get$char: procedure byte;
        if reader$saved = 0 then
            return reader$chr;
        else
            return reader$saved;
    end get$char;

    next$char: procedure;
        if reader$saved = 0 then
        do;
            reader$prev = reader$chr;
            reader$ptr = reader$ptr + 1;
        end;
        else
        do;
            reader$saved = 0;
        end;
    end next$char;

    unread$char: procedure;
        reader$saved = reader$prev;
    end unread$char;

    check$char: procedure (chr) boolean;
        declare chr byte;
        if not input$end then
        do;
            if chr = get$char then
            do;
                call next$char;
                return true;
            end;
        end;
        return false;
    end check$char;

    check$2chars: procedure (c1, c2) boolean;
        declare (c1, c2) byte;
        if check$char(c1) then
        do;
            if check$char(c2) then
                return true;
            else
                call unread$char;
        end;
        return false;
    end check$2chars;


    /* TOKENIZER */
    /* tokenizer variables */
    declare tkn$rd boolean initial (false);
    declare tkn$id byte;
    declare tkn$val uint public;
    declare tkn$str pointer public;
    declare tbuf$len literally '80h';
    declare tok$buf (tbuf$len) byte;

    is$character: procedure (tok$id) boolean;
        declare tok$id byte;
        return tok$id >= 50 and tok$id <= 62;
    end is$character;

    is$keyword: procedure (tok$id) boolean;
        declare tok$id byte;
        return tok$id >= 100 and tok$id <= 150;
    end is$keyword;


    /* check whether the character is an identifier or a keyword character */
    word$char: procedure (chr) boolean;
        declare chr byte;
        if chr >= 'a' and chr <= 'z' then
            return true;
        if chr >= 'A' and chr <= 'Z' then
            return true;
/*
        if chr >= '0' and chr <= '9' then
            return true;
        if chr = '$' or chr = '_' then
            return true;
*/
        return false;
    end word$char;

    /* check whether the character is a decimal digit */
    dec$char: procedure (chr) boolean;
        declare chr byte;
        return chr >= '0' and chr <= '9';
    end dec$char;

    /* checks whether chr is equivalent to a space */
    space$char: procedure (chr) boolean;
        declare chr byte;
        return chr = space or chr = tab or chr = lf or chr = cr;
    end space$char;

    /* skips characters equivalent to a space */
    skip$spaces: procedure;
        do while space$char(get$char);
            call next$char;
        end;
    end skip$spaces;

    /* skip the comment after the '/*' sequence was read */
    skip$comment: procedure;
        declare star$state boolean;
        star$state = false;
        do while not input$end and not (star$state and get$char = '/');
            star$state = (get$char = '*');
            call next$char;
        end;
        if not input$end then
            call next$char;
    end skip$comment;

    /* check if tkn$str is a keyword, and if so return it,
       otherwise return tok$ident
    */
    str$tok$id: procedure byte;
        if string$equal(tkn$str, .('DECLARE', 0)) then
            return tok$declare;
        else if string$equal(tkn$str, .('BYTE', 0)) then
            return tok$byte;
        else if string$equal(tkn$str, .('DO', 0)) then
            return tok$do;
        else if string$equal(tkn$str, .('END', 0)) then
            return tok$end;
        else /***/
            return tok$ident;
    end str$tok$id;

    /* read a string literal together with the terminating quote */
    read$string: procedure;
        declare buffer$ptr pointer;
        declare buffer$chr based buffer$ptr byte;
        buffer$ptr = .tok$buf;
        tkn$str = buffer$ptr;
        call next$char;    /* skip the first quote character */
        /* TODO: implement two quote characters as quote character in string */
        /* check buffer length before writing */
        do while not input$end and get$char <> quote
                    and buffer$ptr - tkn$str < tbuf$len - 1;
            buffer$chr = get$char;
            buffer$ptr = buffer$ptr + 1;
            call next$char;
        end;
        buffer$chr = 0;
        tkn$rd = true;
        tkn$id = tok$string;
        if not input$end then
            call next$char;
    end read$string;

    /* read a string that may be an identifier or a keyword */
    read$word: procedure;
        declare buffer$ptr pointer;
        declare buffer$chr based buffer$ptr byte;
        buffer$ptr = .tok$buf;
        tkn$str = buffer$ptr;
        /* check buffer length before writing */
        do while not input$end and word$char(get$char)
                    and buffer$ptr - tkn$str < tbuf$len - 1;
            buffer$chr = get$char;
            buffer$ptr = buffer$ptr + 1;
            call next$char;
        end;
        buffer$chr = 0;
        tkn$rd = true;
        tkn$id = str$tok$id;
    end read$word;

    /* read a number from the input */
    read$number: procedure;
        declare n uint;
        n = 0;
        do while dec$char(get$char);
            n = n * 10 + get$char - '0';
            call next$char;
        end;
        tkn$id = tok$number;
        tkn$val = n;
        tkn$rd = true;
    end read$number;

    read$char: procedure;
/*
        call print$string(.('[readchar:',0));
        call print$char(reader$chr);
        call print$char(':');
        call print$number(reader$chr);
        call print$char(']');
*/
        if not input$end then
        do;
            tkn$val = get$char;
            if get$char = '+' then
                tkn$id = tok$plus;
            else if get$char = '-' then
                tkn$id = tok$minus;
            else if get$char = '*' then
                tkn$id = tok$star;
            else if get$char = '/' then
                tkn$id = tok$slash;
/*
            else if get$char = '<' then
                tkn$id = tok$lower;
            else if get$char = '>' then
                tkn$id = tok$greater;
            else if get$char = '=' then
                tkn$id = tok$equals;
            else if get$char = ':' then
                tkn$id = tok$colon;
            else if get$char = ';' then
                tkn$id = tok$semicolon;
*/
            else if get$char = '(' then
                tkn$id = tok$par$op;
            else if get$char = ')' then
                tkn$id = tok$par$cl;
/*
            else if get$char = '@' then
                tkn$id = tok$at;
            else if get$char = '_' then
                tkn$id = tok$underscore;
*/
            else
                tkn$id = tok$unknown;
            call next$char;
            tkn$rd = true;
        end;
    end read$char;

    tok$next: procedure public;
        call skip$spaces;    /* skip spaces before reading the next token */

        /* Skip all comments. */
        do while check$2chars('/', '*');
            call skip$comment;
            call skip$spaces;
        end;
        if input$end then
            tkn$id = tok$eof;
        else if get$char = quote then
            call read$string;
        else if dec$char(get$char) then
            call read$number;
        else if word$char(get$char) then
            call read$word;
        else
            call read$char;
    end tok$next;

    get$token: procedure byte public;
        if not tkn$rd then
            call tok$next;
        return tkn$id;
    end get$token;




    pr$chr$tok: procedure (tok$id);
        declare tok$id byte;
        call print$string(.('CHR[', 0));
        call print$char(low(tkn$val));
        call print$char(']');
/*
        if tok$id = tok$plus then
            call print$string(.('PLUS', 0));
        else if tok$id = tok$minus then
            call print$string(.('MINUS', 0));
        else if tok$id = tok$star then
            call print$string(.('STAR', 0));
        else if tok$id = tok$slash then
            call print$string(.('SLASH', 0));
        else if tok$id = tok$lower then
            call print$string(.('LOWER', 0));
        else if tok$id = tok$greater then
            call print$string(.('GREATER', 0));
        else if tok$id = tok$colon then
            call print$string(.('COLON', 0));
        else if tok$id = tok$semicolon then
            call print$string(.('SEMICOLON', 0));
        else if tok$id = tok$par$op then
            call print$string(.('PAR_OP', 0));
        else if tok$id = tok$par$cl then
            call print$string(.('PAR_CL', 0));
        else if tok$id = tok$at then
            call print$string(.('AT', 0));
        else if tok$id = tok$underscore then
            call print$string(.('UNDERSCORE', 0));
*/
    end pr$chr$tok;

    pr$kw$tok: procedure (tok$id);
        declare tok$id byte;
        if tok$id = tok$declare then
            call print$string(.('DECLARE', 0));
        else if tok$id = tok$byte then
            call print$string(.('BYTE', 0));
        else if tok$id = tok$do then
            call print$string(.('DO', 0));
        else if tok$id = tok$end then
            call print$string(.('END', 0));
    end pr$kw$tok;

    /* print token without new line */
    pr$tok: procedure public;
        call print$string(.('TOKEN: ', 0));
        if tkn$id = tok$ident then
        do;
            call print$string(.('IDENTIFIER:', 0));
            call print$string(tkn$str);
            return;
        end;
        if tkn$id = tok$number then
        do;
            call print$string(.('NUMBER:', 0));
            call print$number(tkn$val);
            return;
        end;
        if tkn$id = tok$string then
        do;
            call print$string(.('STRING: [', 0));
            call print$string(tkn$str);
            call print$char(']');
        end;
        else if tkn$id = tok$eof then
            call print$string(.('END OF INPUT', 0));
        else if is$character(tkn$id) then
            call pr$chr$tok(tkn$id);
        else if is$keyword(tkn$id) then
            call pr$kw$tok(tkn$id);
        else /***/
        do;
            call print$string(.('UNKNOWN TOKEN:', 0));
            call print$number(tkn$id);
        end;
    end pr$tok;

end;
