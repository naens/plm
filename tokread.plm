    /* READER */
    /* reader variables */
    declare reader$ptr pointer;   /* pointer to the current string */
    declare reader$chr based reader$ptr byte;
    declare reader$prev byte initial (0);
    declare reader$saved byte initial (0);

    input$end: procedure boolean;
        return reader$chr = 0;
    end input$end;

    get$char: procedure byte;
        if reader$saved = 0 then
            return reader$chr;
        else
            return reader$saved;
    end get$char;

    next$char: procedure;
        if reader$saved = 0 then
        do;
            reader$prev = reader$chr;
            reader$ptr = reader$ptr + 1;
        end;
        else
        do;
            reader$saved = 0;
        end;
    end next$char;

    unread$char: procedure;
        reader$saved = reader$prev;
    end unread$char;

    check$char: procedure (chr) boolean;
        declare chr byte;
        if not input$end then
        do;
            if chr = get$char then
            do;
                call next$char;
                return true;
            end;
        end;
        return false;
    end check$char;

    check$2chars: procedure (c1, c2) boolean;
        declare (c1, c2) byte;
        if check$char(c1) then
        do;
            if check$char(c2) then
                return true;
            else
                call unread$char;
        end;
        return false;
    end check$2chars;


    /* TOKENIZER */
    /* tokenizer variables */
    declare token$ready boolean initial (false);
    declare token$id byte;
    declare token$value uint;
    declare token$str pointer;
    declare tbuf$len literally '80h';
    declare tok$buf (tbuf$len) byte;

    /* token ids */
    declare end$of$input literally '0';
    declare keyword literally '1';
    declare identifier literally '2';
    declare number literally '3';

    /* special characters */
    declare tok$plus literally '100';
    declare tok$minus literally '101';
    declare tok$star literally '102';
    declare tok$slash literally '103';
    declare tok$lower literally '104';
    declare tok$greater literally '105';
    declare tok$equals literally '106';
    declare tok$colon literally '107';
    declare tok$semicolon literally '108';
    declare tok$par$op literally '109';
    declare tok$par$cl literally '110';
    declare tok$at literally '111';
    declare tok$underscore literally '112';

    declare tok$unknown literally '0ffh';


    /* check whether the character is an identifier or a keyword character */
    word$char: procedure (chr) boolean;
        declare chr byte;
        if chr >= 'a' and chr <= 'z' then
            return true;
        if chr >= 'A' and chr <= 'Z' then
            return true;
/*
        if chr >= '0' and chr <= '9' then
            return true;
        if chr = '$' or chr = '_' then
            return true;
*/
        return false;
    end word$char;

    /* check whether the character is a decimal digit */
    dec$char: procedure (chr) boolean;
        declare chr byte;
        return chr >= '0' and chr <= '9';
    end dec$char;

    /* checks whether chr is equivalent to a space */
    space$char: procedure (chr) boolean;
        declare chr byte;
        return chr = space or chr = tab or chr = lf or chr = cr;
    end space$char;

    /* skips characters equivalent to a space */
    /* TODO: also skip comments */
    skip$spaces: procedure;
        do while space$char(get$char);
            call next$char;
        end;
    end skip$spaces;

    /* skip the comment after the '/*' sequence was read */
    skip$comment: procedure;
        declare star$state boolean;
        star$state = false;
        do while not input$end and not (star$state and get$char = '/');
            star$state = (get$char = '*');
            call next$char;
        end;
        if not input$end then
            call next$char;
    end skip$comment;

    /* read a string that may be an identifier or a keyword */
    read$word: procedure;
        declare buffer$ptr pointer;
        declare buffer$chr based buffer$ptr byte;
        buffer$ptr = .tok$buf;
        token$id = identifier;
        token$str = buffer$ptr;
        /* TODO: check buffer length before writing! */
        /* buffer length is in constant tbuf$len */
        do while not input$end and word$char(get$char);
            buffer$chr = get$char;
            buffer$ptr = buffer$ptr + 1;
            call next$char;
        end;
        buffer$chr = 0;
        token$ready = true;
    end read$word;

    /* read a number from the input */
    read$number: procedure ;
        declare n uint;
        n = 0;
        do while dec$char(get$char);
            n = n * 10 + get$char - '0';
            call next$char;
        end;
        token$id = number;
        token$value = n;
        token$ready = true;
    end read$number;

    read$char: procedure;
/*
        call print$string(.('[readchar:',0));
        call print$char(reader$chr);
        call print$char(':');
        call print$number(reader$chr);
        call print$char(']');
*/
        if not input$end then
        do;
            if get$char = '+' then
                token$id = tok$plus;
            else if get$char = '-' then
                token$id = tok$minus;
            else if get$char = '*' then
                token$id = tok$star;
            else if get$char = '/' then
                token$id = tok$slash;
            else if get$char = '<' then
                token$id = tok$lower;
            else if get$char = '>' then
                token$id = tok$greater;
            else if get$char = '=' then
                token$id = tok$equals;
            else if get$char = ':' then
                token$id = tok$colon;
            else if get$char = ';' then
                token$id = tok$semicolon;
            else if get$char = '(' then
                token$id = tok$par$op;
            else if get$char = ')' then
                token$id = tok$par$cl;
            else if get$char = '@' then
                token$id = tok$at;
            else if get$char = '_' then
                token$id = tok$underscore;
            else
                token$id = tok$unknown;
            call next$char;
            token$ready = true;
        end;
    end read$char;

    read$token: procedure;
        call skip$spaces;    /* skip spaces before reading the next token */

        /* Skip all comments. */
        do while check$2chars('/', '*');
            call skip$comment;
            call skip$spaces;
        end;
        if input$end then
            token$id = end$of$input;
        else if dec$char(get$char) then
            call read$number;
        else if word$char(get$char) then
            call read$word;
        else
            call read$char;
    end read$token;

    get$token: procedure byte;
        if not token$ready then
            call read$token;
        return token$id;
    end get$token;


    /* print token without new line */
    print$token: procedure;
        call print$string(.('TOKEN: ', 0));
        if token$id = identifier then
        do;
            call print$string(.('IDENTIFIER:', 0));
            call print$string(token$str);
        end;
        else if token$id = number then
        do;
            call print$string(.('NUMBER:', 0));
            call print$number(token$value);
        end;
        else if token$id = end$of$input then
            call print$string(.('END OF INPUT', 0));
        else if token$id = tok$plus then
            call print$string(.('PLUS', 0));
        else if token$id = tok$minus then
            call print$string(.('MINUS', 0));
        else if token$id = tok$star then
            call print$string(.('STAR', 0));
        else if token$id = tok$slash then
            call print$string(.('SLASH', 0));
        else if token$id = tok$lower then
            call print$string(.('LOWER', 0));
        else if token$id = tok$greater then
            call print$string(.('GREATER', 0));
        else if token$id = tok$colon then
            call print$string(.('COLON', 0));
        else if token$id = tok$semicolon then
            call print$string(.('SEMICOLON', 0));
        else if token$id = tok$par$op then
            call print$string(.('PAR_OP', 0));
        else if token$id = tok$par$cl then
            call print$string(.('PAR_CL', 0));
        else if token$id = tok$at then
            call print$string(.('AT', 0));
        else if token$id = tok$underscore then
            call print$string(.('UNDERSCORE', 0));
        else /***/
        do;
            call print$string(.('UNKNOWN TOKEN:', 0));
            call print$number(token$id);
        end;
    end print$token;

